#include <ctime>
#include <cstdio>
#include <string>
#include <vector>
#include <cmath>
#include <cstring>
#include <cstdlib>

#include "PractRand/config.h"
#include "PractRand/rng_basics.h"
#include "PractRand/rng_helpers.h"
#include "PractRand/rng_internals.h"

//for use in seeding & self-tests:
#include "PractRand/RNGs/all.h"

/*
	currently the only non-uniform distribution supported is the Gaussian distribution
*/

namespace PractRand {
	namespace Internals {

		/*
			Gaussian/Normal distribution implementation

			Rolled my own.  
			Possibly a standard Ziggaraut method would work better, but this is simple and it works and it can be replaced later. 
			I suppose this does have the merit of using a fixed number of input bits.  

			At GAUSSIAN_CDF_TABLE_SIZE=256 this needs 2 KB of memory.  I'm not sure if that's too much or not enough.  
			It seems like a waste to spend 1 KB on something that many people will never use, but the linker may be smart enough to discard it.  
			If I went to a 16 KB table size then I could speed it up a tad without compromising quality too much, but this is fast enough for now.  

			I'm aiming for 25 or so bits of good resolution plus another 25 or so bits of noise here - 
			good enough to be practically impossible to distinguish from from true gaussian, and significantly better than single precision floats, but not quite maxing 
			out what double precision numbers can manage.  More than that and I would have have a hard time verifying things without large number types 
			and even more exotic math.  
		*/
		enum {GAUSSIAN_CDF_TABLE_SIZE_L2=8, GAUSSIAN_CDF_TABLE_SIZE = 1 << GAUSSIAN_CDF_TABLE_SIZE_L2};
		static const float primary_gaussian_cdf_table[GAUSSIAN_CDF_TABLE_SIZE] = {
			-1.6163263225, -1.3196592415, -1.1954910794, -1.1114453849, -1.0462748154, -0.9923525680, -0.9459735161, -0.9050338462, -0.8682159066, -0.8346362318, -0.8036718505, -0.7748660434, -0.7478734240, -0.7224260936, -0.6983118212, -0.6753594409, 
			-0.6534287703, -0.6324034597, -0.6121858041, -0.5926929007, -0.5738537537, -0.5556070563, -0.5378994703, -0.5206842715, -0.5039202731, -0.4875709602, -0.4716037875, -0.4559896044, -0.4407021805, -0.4257178113, -0.4110149884, -0.3965741208, 
			-0.3823772996, -0.3684080969, -0.3546513939, -0.3410932322, -0.3277206858, -0.3145217497, -0.3014852421, -0.2886007196, -0.2758584016, -0.2632491046, -0.2507641824, -0.2383954749, -0.2261352601, -0.2139762133, -0.2019113685, -0.1899340848, 
			-0.1780380153, -0.1662170791, -0.1544654357, -0.1427774615, -0.1311477279, -0.1195709818, -0.1080421265, -0.0965562049, -0.0851083829, -0.0736939343, -0.0623082262, -0.0509467056, -0.0396048858, -0.0282783338, -0.0169626579, -0.0056534962, 
			+0.0056534962, +0.0169626579, +0.0282783338, +0.0396048858, +0.0509467056, +0.0623082262, +0.0736939343, +0.0851083829, +0.0965562049, +0.1080421265, +0.1195709818, +0.1311477279, +0.1427774615, +0.1544654357, +0.1662170791, +0.1780380153, 
			+0.1899340848, +0.2019113685, +0.2139762133, +0.2261352601, +0.2383954749, +0.2507641824, +0.2632491046, +0.2758584016, +0.2886007196, +0.3014852421, +0.3145217497, +0.3277206858, +0.3410932322, +0.3546513939, +0.3684080969, +0.3823772996, 
			+0.3965741208, +0.4110149884, +0.4257178113, +0.4407021805, +0.4559896044, +0.4716037875, +0.4875709602, +0.5039202731, +0.5206842715, +0.5378994703, +0.5556070563, +0.5738537537, +0.5926929007, +0.6121858041, +0.6324034597, +0.6534287703, 
			+0.6753594409, +0.6983118212, +0.7224260936, +0.7478734240, +0.7748660434, +0.8036718505, +0.8346362318, +0.8682159066, +0.9050338462, +0.9459735161, +0.9923525680, +1.0462748154, +1.1114453849, +1.1954910794, +1.3196592415, +1.6163263225
		};
		static const float secondary_gaussian_cdf_table[GAUSSIAN_CDF_TABLE_SIZE] = {
			+1.0270065287e-010, +3.5445721984e-011, +2.2374584217e-011, +1.6762242066e-011, +1.3585169202e-011, +1.1524333934e-011, +1.0072595101e-011, +8.9914242845e-012, +8.1532648440e-012, +7.4834897566e-012, +6.9354238958e-012, +6.4783253196e-012, +6.0910925944e-012, +5.7587440258e-012, +5.4703391261e-012, +5.2176958089e-012,
			+4.9945685304e-012, +4.7961046655e-012, +4.6184748659e-012, +4.4586155873e-012, +4.3140458994e-012, +4.1827346681e-012, +4.0630026198e-012, +3.9534490258e-012, +3.8528960586e-012, +3.7603460307e-012, +3.6749481583e-012, +3.5959724575e-012, +3.5227890436e-012, +3.4548515714e-012, +3.3916838777e-012, +3.3328691249e-012,
			+3.2780409160e-012, +3.2268759731e-012, +3.1790880693e-012, +3.1344229687e-012, +3.0926541857e-012, +3.0535794117e-012, +3.0170174920e-012, +2.9828058540e-012, +2.9507983138e-012, +2.9208631954e-012, +2.8928817138e-012, +2.8667465801e-012, +2.8423607943e-012, +2.8196365979e-012, +2.7984945628e-012, +2.7788627969e-012,
			+2.7606762508e-012, +2.7438761111e-012, +2.7284092696e-012, +2.7142278580e-012, +2.7012888411e-012, +2.6895536597e-012, +2.6789879199e-012, +2.6695611208e-012, +2.6612464195e-012, +2.6540204272e-012, +2.6478630353e-012, +2.6427572677e-012, +2.6386891581e-012, +2.6356476497e-012, +2.6336245174e-012, +2.6326143094e-012,
			+2.6326143094e-012, +2.6336245174e-012, +2.6356476497e-012, +2.6386891581e-012, +2.6427572677e-012, +2.6478630353e-012, +2.6540204272e-012, +2.6612464195e-012, +2.6695611208e-012, +2.6789879199e-012, +2.6895536597e-012, +2.7012888411e-012, +2.7142278580e-012, +2.7284092696e-012, +2.7438761111e-012, +2.7606762508e-012,
			+2.7788627969e-012, +2.7984945628e-012, +2.8196365979e-012, +2.8423607943e-012, +2.8667465801e-012, +2.8928817138e-012, +2.9208631954e-012, +2.9507983138e-012, +2.9828058540e-012, +3.0170174920e-012, +3.0535794117e-012, +3.0926541857e-012, +3.1344229687e-012, +3.1790880693e-012, +3.2268759731e-012, +3.2780409160e-012,
			+3.3328691249e-012, +3.3916838777e-012, +3.4548515714e-012, +3.5227890436e-012, +3.5959724575e-012, +3.6749481583e-012, +3.7603460307e-012, +3.8528960586e-012, +3.9534490258e-012, +4.0630026198e-012, +4.1827346681e-012, +4.3140458994e-012, +4.4586155873e-012, +4.6184748659e-012, +4.7961046655e-012, +4.9945685304e-012,
			+5.2176958089e-012, +5.4703391261e-012, +5.7587440258e-012, +6.0910925944e-012, +6.4783253196e-012, +6.9354238958e-012, +7.4834897566e-012, +8.1532648440e-012, +8.9914242845e-012, +1.0072595101e-011, +1.1524333934e-011, +1.3585169202e-011, +1.6762242066e-011, +2.2374584217e-011, +3.5445721984e-011, +1.0270065287e-010
		};
		double generate_gaussian_fast(Uint64 raw64) {//fast CDF-based hybrid method
			Sint32 si = Sint32(raw64 >> 32);
			Uint32 indeces = Uint32(raw64);
			long index = (indeces >> (GAUSSIAN_CDF_TABLE_SIZE_L2*0)) & (GAUSSIAN_CDF_TABLE_SIZE-1);
			double rv = primary_gaussian_cdf_table[index];
			rv += si * secondary_gaussian_cdf_table[index];
			index = (indeces >> (GAUSSIAN_CDF_TABLE_SIZE_L2*1)) & (GAUSSIAN_CDF_TABLE_SIZE-1);
			rv += primary_gaussian_cdf_table[index];
			index = (indeces >> (GAUSSIAN_CDF_TABLE_SIZE_L2*2)) & (GAUSSIAN_CDF_TABLE_SIZE-1);
			rv += primary_gaussian_cdf_table[index];
			return rv;
		}

		enum {GAUSSIAN_PDF_TABLE_SIZE_L2=8, GAUSSIAN_PDF_TABLE_SIZE = 1 << GAUSSIAN_PDF_TABLE_SIZE_L2};
		static const float gaussian_pdf_table_x[GAUSSIAN_PDF_TABLE_SIZE - 1] = {
			0.272321, 0.362871, 0.426548, 0.477438, 0.520656, 0.558692, 0.592963, 0.624359, 0.653479, 0.680748, 0.706480, 0.730912, 0.754231, 0.776584, 0.798092, 0.818854, 
			0.838952, 0.858457, 0.877428, 0.895915, 0.913965, 0.931616, 0.948903, 0.965855, 0.982501, 0.998864, 1.014968, 1.030830, 1.046471, 1.061906, 1.077151, 1.092219, 
			1.107124, 1.121877, 1.136490, 1.150973, 1.165336, 1.179587, 1.193737, 1.207792, 1.221760, 1.235649, 1.249466, 1.263218, 1.276910, 1.290550, 1.304142, 1.317693, 
			1.331208, 1.344693, 1.358152, 1.371592, 1.385017, 1.398432, 1.411842, 1.425251, 1.438665, 1.452088, 1.465526, 1.478982, 1.492461, 1.505969, 1.519509, 1.533088, 
			1.546708, 1.560377, 1.574098, 1.587877, 1.601718, 1.615628, 1.629611, 1.643674, 1.657822, 1.672060, 1.686396, 1.700836, 1.715386, 1.730054, 1.744846, 1.759770, 
			1.774834, 1.790046, 1.805416, 1.820952, 1.836665, 1.852564, 1.868661, 1.884966, 1.901494, 1.918257, 1.935269, 1.952545, 1.970103, 1.987959, 2.006133, 2.024647, 
			2.043521, 2.062782, 2.082456, 2.102573, 2.123165, 2.144270, 2.165926, 2.188180, 2.211081, 2.234686, 2.259059, 2.284273, 2.310413, 2.337574, 2.365870, 2.395433, 
			2.426419, 2.459017, 2.493453, 2.530008, 2.569032, 2.610971, 2.656405, 2.706112, 2.761167, 2.823123, 2.894341, 2.978693, 3.083225, 3.223079, 3.442610
		};
		static const float gaussian_pdf_table_y[GAUSSIAN_PDF_TABLE_SIZE - 1] = {
			0.384421, 0.373523, 0.364252, 0.355969, 0.348374, 0.341295, 0.334626, 0.328292, 0.322241, 0.316432, 0.310834, 0.305424, 0.300181, 0.295089, 0.290134, 
			0.285304, 0.280590, 0.275984, 0.271477, 0.267063, 0.262736, 0.258491, 0.254324, 0.250230, 0.246205, 0.242246, 0.238349, 0.234513, 0.230734, 0.227010, 0.223339, 
			0.219718, 0.216146, 0.212621, 0.209142, 0.205706, 0.202312, 0.198960, 0.195647, 0.192373, 0.189136, 0.185936, 0.182771, 0.179640, 0.176543, 0.173479, 0.170447, 
			0.167446, 0.164475, 0.161534, 0.158623, 0.155739, 0.152884, 0.150056, 0.147255, 0.144481, 0.141732, 0.139009, 0.136310, 0.133636, 0.130987, 0.128361, 0.125758, 
			0.123179, 0.120622, 0.118088, 0.115576, 0.113085, 0.110616, 0.108168, 0.105742, 0.103336, 0.100951, 0.098585, 0.096240, 0.093915, 0.091610, 0.089324, 0.087058, 
			0.084811, 0.082583, 0.080373, 0.078183, 0.076011, 0.073858, 0.071724, 0.069607, 0.067509, 0.065430, 0.063368, 0.061325, 0.059299, 0.057292, 0.055303, 0.053332, 
			0.051379, 0.049443, 0.047526, 0.045627, 0.043746, 0.041884, 0.040040, 0.038214, 0.036407, 0.034618, 0.032849, 0.031098, 0.029367, 0.027655, 0.025963, 0.024292, 
			0.022641, 0.021011, 0.019403, 0.017817, 0.016254, 0.014715, 0.013200, 0.011712, 0.010250, 0.008818, 0.007417, 0.006051, 0.004723, 0.003441, 0.002214, 0.001065
		};
		double tail_p = 0.000288;//, tail_scale = 3.713077;
		double generate_gaussian_high_quality(Uint64 raw192[3]) {//slow PDF-based (ziggurat) method
			//since we take a finite number of inputs, we can't afford to retry indefinitely
			//so...
			//word0: 8 bits for stripe, 54 bits for signed x coordinate, remaining 2 bits unused
			//word1: 53 bits for unsigned y coordinate
			//word2: either call the cdf-based method (64 bits from word2), or switch to a crude trapezoidal-pdf-based method (32+32 bits from word2 and 8 more bits from word1)
			return 0;
		}
	}
}
